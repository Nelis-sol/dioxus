package dev.dioxus.main

import android.net.Uri
import com.funkatronic.encoders.Base58
import android.util.Log
import androidx.activity.ComponentActivity
import androidx.annotation.Keep
import com.solana.mobilewalletadapter.clientlib.ActivityResultSender
import com.solana.mobilewalletadapter.clientlib.ConnectionIdentity
import com.solana.mobilewalletadapter.clientlib.MobileWalletAdapter
import com.solana.mobilewalletadapter.clientlib.TransactionResult
import com.solana.mobilewalletadapter.clientlib.protocol.MobileWalletAdapterClient // For AuthorizationResult
import com.solana.mobilewalletadapter.clientlib.Blockchain
import com.solana.mobilewalletadapter.clientlib.Solana // Specific blockchain implementation
// SignInWithSolana might be needed if we add sign-in functionality later
// import com.solana.mobilewalletadapter.common.signin.SignInWithSolana 
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch

@Keep
class DioxusUtils {
    companion object {
        private const val TAG = "DioxusMWA"

        @Keep
        @JvmStatic
        fun getHardcodedString(): String {
            return "Hello from DioxusUtils in Kotlin!"
        }

        @Keep
        @JvmStatic
        fun establishMwaSession(activity: ComponentActivity): String { // Changed to ComponentActivity
            Log.d(TAG, "establishMwaSession called for activity: $activity")

            // Retrieve the pre-initialized ActivityResultSender from MainActivity
            val sender: ActivityResultSender = if (activity is MainActivity) {
                activity.mwaActivityResultSender
            } else {
                Log.e(TAG, "Activity passed to establishMwaSession is not an instance of MainActivity. Cannot get mwaActivityResultSender.")
                // Fallback or error handling: Potentially create a new one, but this might lead to the same lifecycle issue
                // if called too late. For now, returning an error message is safer.
                return "Error: Activity is not MainActivity instance, cannot securely get ActivityResultSender."
            }
            
            // AppIdentity is replaced by ConnectionIdentity and MobileWalletAdapterConfig is no longer directly used here.
            // Timeout will be passed directly to the MobileWalletAdapter constructor.
            val connectionIdentity = ConnectionIdentity(
                identityName = "Dioxus Demo App", // Replace with your app's name
                identityUri = Uri.parse("https://pub-1ec9c4f3ba9448c6a82b677a2bc8d950.r2.dev"),
                iconUri = Uri.parse("favicon.ico")
            )
            
            // The MobileWalletAdapter constructor has changed.
            // We'll use the ConnectionIdentity and a default timeout for now.
            // MobileWalletAdapter(connectionIdentity, timeout, ioDispatcher, scenarioProvider)
            // For simplicity, let's use the default timeout from the new MWA class or define one.
            // The new MWA takes ConnectionIdentity as the first param.
            // `sender` is used within the `transact` method, not in constructor.
            // `config` is not used in the new MWA constructor.
            val walletAdapter = MobileWalletAdapter(connectionIdentity) // Using default timeout

            Log.d(TAG, "MobileWalletAdapter instance created. ConnectionIdentity: ${connectionIdentity.identityName}")

            CoroutineScope(Dispatchers.IO).launch {
                Log.d(TAG, "Attempting MWA transaction for authorization...")
                // Set desired blockchain (e.g., Solana.Devnet, Solana.Mainnet)
                walletAdapter.blockchain = Solana.Mainnet

                val result = walletAdapter.transact(sender) { authResult ->
                    // This block is executed after successful association and authorization.
                    // The authResult here is MobileWalletAdapterClient.AuthorizationResult
                    Log.i(TAG, "MWA Transaction/Authorization Success!")
                    Log.i(TAG, "  AuthToken: ${authResult.authToken}")

                    // Send the public key to the Rust layer
                    authResult.accounts.firstOrNull()?.let { account ->
                        val publicKeyBase58 = Base58.encodeToString(account.publicKey)
                        Log.i(TAG, "Sending public key to Rust: $publicKeyBase58")
                        Ipc.sendPublicKey(publicKeyBase58)
                    }

                    authResult.walletUriBase?.let { uri ->
                        Log.i(TAG, "  Wallet URI Base: $uri")
                    }

                    // TODO: Securely store authToken and other relevant details.
                    // You can return a value from this block if needed by the transact method's signature,
                    // but for simple authorization, Unit is fine.
                    Unit
                }

                when (result) {
                    is TransactionResult.Success -> {
                        // The actual success logging for authorization details is handled inside the transact block.
                        // This 'result.data' would be Unit in this case.
                        // The 'result.authResult' contains the authorization details again if needed here.
                        Log.i(TAG, "MWA transact operation completed successfully.")
                        // Example accessing authResult again if necessary:
                        // val authData = result.authResult
                        // Log.i(TAG, "  AuthToken from TransactionResult.Success: ${authData.authToken}")
                    }
                    is TransactionResult.Failure -> {
                        Log.e(TAG, "MWA Transaction Failed: ${result.message}", result.e)
                        // Specific error types like NoWalletFound are now distinct TransactionResult types.
                        // Other errors are generally caught here.
                        // You can inspect result.e for more specific causes if needed.
                        // For example, if (result.e is MobileWalletAdapterClient.NotSubmittedException) { ... }
                    }
                    is TransactionResult.NoWalletFound -> {
                        Log.w(TAG, "MWA Transaction Failed: No compatible wallet found. Message: ${result.message}")
                    }
                    // There isn't a direct "Cancelled" or "Interrupted" TransactionResult type like this.
                    // Interruptions/cancellations usually manifest as exceptions leading to TransactionResult.Failure.
                    // For example, if the user cancels the activity launched by `sender.startActivityForResult`,
                    // it might throw an InterruptedException, caught by the associate method, leading to Failure.
                }
            }
            
            val immediateReturnMessage = "MWA authorization process initiated. Check Logcat for '$TAG' for asynchronous result."
            Log.d(TAG, immediateReturnMessage)
            return immediateReturnMessage
        }
    }
}
